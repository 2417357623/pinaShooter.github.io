<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/09/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>VUE是如何渲染SPA的</title>
    <url>/2024/09/28/VUE%E6%98%AF%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93SPA%E7%9A%84/</url>
    <content><![CDATA[<h2 id="涉及到的知识面"><a href="#涉及到的知识面" class="headerlink" title="涉及到的知识面"></a>涉及到的知识面</h2><p>正则表达式，数据劫持，虚拟 DOM</p>
<h2 id="简易流程加虚拟-DOM"><a href="#简易流程加虚拟-DOM" class="headerlink" title="简易流程加虚拟 DOM"></a>简易流程加虚拟 DOM</h2><p>为了可以介绍清楚整个转化流程，我将拿一个简单地 <code>.vue</code> 文件举例子，并把整个渲染流程代码逐个拆分到每个步骤中去。这个例子会涉及响应式和虚拟 DOM。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            title: &quot;this is title&quot;,</span><br><span class="line">            content: &quot;this is Content&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="SFC转为JS"><a href="#SFC转为JS" class="headerlink" title="SFC转为JS"></a>SFC转为JS</h3><p>由于浏览器只能识别 <code>http | js | css</code>  文件，所以 <code>vite</code> 官方 提供一个<code>@vitejs/plugin-vue</code> 组件，可以把这个插件想象成编译器，把 <code>.vue</code> 文件转化为 <code>.js</code>文件。为了更好的探究实现过程，我决定手写，这时候就涉及到读取vue文件，把内容转为字符串输出。</p>
<p>早期，浏览器是一个沙盒，它不允许我们操作本地文件，通常都是后端处理，前端使用 <code>fetch</code> API 或 <code>XMLHttpRequest</code> 来发送请求到后端拿到数据。浏览器只允许同源的Ajax操作，如果跨域，就必须使用CORS权限。<br>除此之外，还有纯前端操作文件的方法。参考<a class="link"   href="https://blog.csdn.net/xgangzai/article/details/129605068" ># 使用File System Access API让浏览器拥有操作本地文件的能力 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。<br>纯前端方法不是很流行，所以我不做研究。</p>
<p>利用 <code>webpack</code> ，相当于是后端的处理方式，由于 <code>webpack</code> 运行在 <code>Nodejs</code> 上，所以webpack内部在编译的过程帮我们处理了读取文件的步骤，我们只需配置一个loader，参数是从目标文件拿到的字符串信息，返回一个字符串webpack会生成对应的js文件。在loader中编写我们的处理逻辑。</p>
<p>以下手写webpack-loader ，模拟了<code>@vitejs/plugin-vue</code>的编译功能，把vue转化为了js。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regTemplate = <span class="regexp">/\&lt;template\&gt;(.+?)\&lt;\/template\&gt;/</span></span><br><span class="line"><span class="keyword">const</span> regScript = <span class="regexp">/\&lt;script\&gt;(.+?)\&lt;\/script\&gt;/</span></span><br><span class="line"><span class="keyword">const</span> regFirstSign = <span class="regexp">/(&#123;)/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> _source = source.<span class="title function_">replace</span>(<span class="regexp">/[\r\n]/g</span>,<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">      <span class="keyword">const</span> template = _source.<span class="title function_">match</span>(regTemplate)[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">const</span> script = _source.<span class="title function_">match</span>(regScript)[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">const</span> finalScript = script.<span class="title function_">replace</span>(regFirstSign, <span class="string">&#x27;$1 template:&#x27;</span> + <span class="string">&#x27;`&#x27;</span> + template + <span class="string">&#x27;`&#x27;</span> + <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(finalScript)</span><br><span class="line">      <span class="keyword">return</span> finalScript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//finalScript like this </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">template</span>:<span class="string">`    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;    &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;`</span>,    <span class="title function_">data</span>(<span class="params"></span>) &#123;        <span class="keyword">return</span> &#123;            <span class="attr">title</span>: <span class="string">&quot;this is </span></span><br><span class="line"><span class="string">title&quot;</span>,            <span class="attr">content</span>: <span class="string">&quot;this is Content&quot;</span>,        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></div>


<h3 id="template模板分析，编译"><a href="#template模板分析，编译" class="headerlink" title="template模板分析，编译"></a>template模板分析，编译</h3><p>template分为标签，属性，内容。</p>
<ul>
<li>标签有可能是原生的html，也有可能是组件</li>
<li>属性也有可能是vue框架属性，自定义属性<br>vue会对这些模板做过滤，生成AST树。</li>
</ul>
<p>首先把文件里的template和data解构出来</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//解构出被loader处理过的App.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;template,<span class="attr">data</span>: generate &#125; = <span class="title class_">App</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data  = <span class="title function_">reactive</span>(<span class="title function_">generate</span>())</span><br></pre></td></tr></table></figure></div>

<p>然后对模板进行分析编译，编译包括匹配每个标签和内容，然后生成虚拟的DOM。</p>
<blockquote>
<p>这里是一个简易版本，只针对原生标签的innerHtml做了分析。这个 innerHtml 也并非表达式。除此之外，也没有 vue 的特殊的事件属性写法</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regHtml = <span class="regexp">/\&lt;(.+?)\&gt;\&#123;\&#123;(.+?)\&#125;\&#125;\&lt;\/.+?\&gt;/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">compileTemplate</span> = (<span class="params">template,data</span>)=&gt;&#123;</span><br><span class="line">    <span class="comment">//vDOM原来是对象，这里用数组只是为了展示虚拟节点的思想</span></span><br><span class="line">    <span class="keyword">const</span> vDOM = []</span><br><span class="line">    <span class="keyword">const</span> matched = template.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(regHtml,<span class="string">&quot;ig&quot;</span>))</span><br><span class="line">    matched.<span class="title function_">forEach</span>(<span class="function">(<span class="params">tag,index</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> [,tagName,key] = tag.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(regHtml,<span class="string">&quot;i&quot;</span>))</span><br><span class="line">        </span><br><span class="line">        vDOM[index] = &#123;</span><br><span class="line">            <span class="attr">tag</span>:tagName,</span><br><span class="line">            <span class="attr">children</span>: data[key.<span class="title function_">trim</span>()]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h3 id="render虚拟DOM"><a href="#render虚拟DOM" class="headerlink" title="render虚拟DOM"></a>render虚拟DOM</h3><p>初次渲染只需要把虚拟DOM渲染到真实DOM上</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">app,template,data</span>)=&gt;&#123;</span><br><span class="line">    state.<span class="property">_vDOM</span> = <span class="title function_">compileTemplate</span>(template,data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fragment  =  <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()</span><br><span class="line">    <span class="comment">//只做一层的渲染</span></span><br><span class="line">    state.<span class="property">_vDOM</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">vnode</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;tag,children&#125; = vnode</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并且只做innerText</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tag)</span><br><span class="line">        node.<span class="property">innerText</span> = children</span><br><span class="line"></span><br><span class="line">        fragment.<span class="title function_">appendChild</span>(node)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_">appendChild</span>(fragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h3 id="数据更新，重新渲染"><a href="#数据更新，重新渲染" class="headerlink" title="数据更新，重新渲染"></a>数据更新，重新渲染</h3><p>当数据更新，我们如何追踪这种变化？es6的proxy给了我们答案，通过一种数据劫持的方案，我们可以检测到数据变化，并且做一些额外的（更新视图）的动作。<br>以下是proxy ，set的handler的实现。<br>当数据变更时，我们会根据新的data重新编译模板，获取新的虚拟DOM，通过比较新老虚拟DOM，获取发生变化的虚拟DOM，并在真实DOM上重新渲染这部分的值。</p>
<blockquote>
<p>这种比较涉及了diff算法，这里没有去实现</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">update</span> = (<span class="params">template,vDOM,data,value</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> newVDOM = <span class="title function_">compileTemplate</span>(template,data)</span><br><span class="line"></span><br><span class="line">    newVDOM.<span class="title function_">forEach</span>( <span class="function">(<span class="params">vnode,index</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vnode.<span class="property">children</span> !== vDOM[index].<span class="property">children</span>)&#123;</span><br><span class="line">            <span class="title function_">patch</span>(value,index)</span><br><span class="line">            vDOM.<span class="title function_">splice</span>(<span class="number">0</span>, vDOM.<span class="property">length</span>, ...newVDOM); <span class="comment">// 直接用新内容替换原有内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">value,index</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> childNodes = state.<span class="property">_app</span>.<span class="property">children</span></span><br><span class="line">    childNodes[index].<span class="property">innerText</span> = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createSetter</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">set</span> = (<span class="params">target,key,value,receiver</span>) =&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line">        <span class="comment">//一旦执行这一句，那么target的值立马会发生变化，也就是说，下面的代码的target会立马变成新的值。所以update的参数将会是更新后的data</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target,key,value,receiver)</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target,key))&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应式新增&quot;</span>, + value)</span><br><span class="line">            <span class="title function_">update</span>(state.<span class="property">_template</span>,state.<span class="property">_vDOM</span>,state.<span class="property">_data</span>,value)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value !== oldValue)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应式修改&quot;</span>, key + <span class="string">&quot; = &quot;</span> +  value)</span><br><span class="line">                <span class="title function_">update</span>(state.<span class="property">_template</span>,state.<span class="property">_vDOM</span>,state.<span class="property">_data</span>,value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> get = <span class="title function_">createGetter</span>()</span><br><span class="line"><span class="keyword">const</span> set = <span class="title function_">createSetter</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutableHandler = &#123;</span><br><span class="line">    get,</span><br><span class="line">    set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="流程小结"><a href="#流程小结" class="headerlink" title="流程小结"></a>流程小结</h3><p> 我们需要拆分一下概念，整个实现涉及到了 vue 的响应式，和虚拟 DOM。</p>
<ul>
<li>响应式，使得开发者不需要手动管理 DOM 的更新，Vue 会根据数据的变化自动重新渲染相关部分，减少了出错的可能性。</li>
<li>而虚拟 DOM ，避免了 DOM 的频繁更新，提高性能。<br>Vue 的整个流程是可以绕过虚拟 DOM 实现的，接下来我将实现一个更加复杂的 vue 渲染 <code>.vue</code> 文件的流程。</li>
</ul>
<h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p>以上是 vue 的一个简易版本，由于我认识有限，接下来的内容将会不断更新，以便还原整个 vue 文件运行的流程。</p>
<h3 id="Vue-文件转为-Js-文件"><a href="#Vue-文件转为-Js-文件" class="headerlink" title=".Vue 文件转为. Js 文件"></a>.Vue 文件转为. Js 文件</h3><h3 id="CreateApp-入口函数"><a href="#CreateApp-入口函数" class="headerlink" title="CreateApp 入口函数"></a>CreateApp 入口函数</h3><h3 id="函件加载"><a href="#函件加载" class="headerlink" title="函件加载"></a>函件加载</h3><h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a class="link"   href="https://jonny-wei.github.io/blog/vue/vue/vue-observer.html#%E5%A6%82%E4%BD%95%E4%BE%A6%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96" >响应式原理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.poetries.top/FE-Interview-Questions/principle-docs/comprehensive/07-%E8%99%9A%E6%8B%9FDOM%EF%BC%88%E4%B8%80%EF%BC%89.html#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-vdom" >什么是虚拟 DOM <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.bilibili.com/video/BV1L94y1U73p/?spm_id_from=333.788&vd_source=115cedcdb1996c6483fb453252e441e6" ># JS实现『从工程化到Vue』【上机题】 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.bilibili.com/video/BV1mK421v7PH?p=4&vd_source=115cedcdb1996c6483fb453252e441e6" ># 【小野森森】虚拟DOM怎么了？【前端基础】 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>SPA</tag>
        <tag>渲染原理</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
</search>
